from fastapi import FastAPI, UploadFile, File, HTTPException
from fastapi.responses import JSONResponse
import os
import pydicom
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# Database Configuration
DATABASE_URL = "postgresql://dicomuser:123@localhost:5432/dicomdb"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# DICOM Model
class DicomFile(Base):
    __tablename__ = "dicom_files"
    id = Column(Integer, primary_key=True, index=True)
    filename = Column(String, index=True)
    patient_name = Column(String)
    study_date = Column(String)
    modality = Column(String)
    file_path = Column(String)

Base.metadata.create_all(bind=engine)

# FastAPI App
app = FastAPI()

UPLOAD_DIR = "uploads"
os.makedirs(UPLOAD_DIR, exist_ok=True)

# ✅ Function to parse and store DICOM file directly (for testing)
def parse_and_store_dicom(file_path: str):
    try:
        # Read metadata using pydicom
        dicom_data = pydicom.dcmread(file_path)
        patient_name = dicom_data.get("PatientName", "")
        study_date = dicom_data.get("StudyDate", "")
        modality = dicom_data.get("Modality", "")

        # Save metadata to DB
        db = SessionLocal()
        dicom_entry = DicomFile(
            filename=os.path.basename(file_path),
            patient_name=str(patient_name),
            study_date=str(study_date),
            modality=str(modality),
            file_path=file_path,
        )
        db.add(dicom_entry)
        db.commit()
        db.close()

        print(f"✅ Metadata saved for file: {file_path}")
        print(f"➡️ Patient Name: {patient_name}")
        print(f"➡️ Study Date: {study_date}")
        print(f"➡️ Modality: {modality}")

    except Exception as e:
        print(f"❌ Error: {e}")

# ✅ Endpoint 1: Upload and parse DICOM file
@app.post("/upload/")
async def upload_dicom(file: UploadFile = File(...)):
    file_path = os.path.join(UPLOAD_DIR, file.filename)

    # Save file to storage
    with open(file_path, "wb") as f:
        f.write(await file.read())

    try:
        # Use the same parsing logic for API as the direct function
        parse_and_store_dicom(file_path)

        return {"filename": file.filename, "message": "File uploaded and metadata stored successfully"}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

# ✅ Endpoint 2: Get metadata by filename
@app.get("/metadata/{filename}")
def get_metadata(filename: str):
    db = SessionLocal()
    file_data = db.query(DicomFile).filter(DicomFile.filename == filename).first()
    db.close()

    if not file_data:
        raise HTTPException(status_code=404, detail="File not found")

    return {
        "filename": file_data.filename,
        "patient_name": file_data.patient_name,
        "study_date": file_data.study_date,
        "modality": file_data.modality,
        "file_path": file_data.file_path,
    }

file_path = os.path.join(os.path.dirname(__file__), "1-001.dcm")
parse_and_store_dicom(file_path)







2nd



from fastapi import FastAPI, UploadFile, File, HTTPException
from fastapi.responses import JSONResponse
import os
import pydicom
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime

# ✅ Database Configuration
DATABASE_URL = "postgresql://dicomuser:123@localhost:5432/dicomdb"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# ✅ DICOM Model
class DicomFile(Base):
    __tablename__ = "dicom_files"
    id = Column(Integer, primary_key=True, index=True)
    filename = Column(String, index=True)
    patient_name = Column(String)
    study_date = Column(String)
    modality = Column(String)
    file_path = Column(String)

# ✅ Create database tables if they don't exist
Base.metadata.create_all(bind=engine)

# ✅ FastAPI App
app = FastAPI()

# ✅ Create and confirm upload directory
UPLOAD_DIR = os.path.join(os.path.dirname(__file__), "uploads")
if not os.path.exists(UPLOAD_DIR):
    os.makedirs(UPLOAD_DIR, exist_ok=True)

print(f"✅ Upload directory created at: {UPLOAD_DIR}")
print(f"➡️ Exists: {os.path.exists(UPLOAD_DIR)}")
print(f"➡️ Writable: {os.access(UPLOAD_DIR, os.W_OK)}")
print(f"Current working directory: {os.getcwd()}")

# ✅ Function to validate DICOM file
def is_valid_dicom(file_path: str) -> bool:
    try:
        # Attempt to read the file using pydicom
        pydicom.dcmread(file_path)
        return True
    except Exception as e:
        print(f"❌ Invalid DICOM file: {e}")
        return False

# ✅ Function to parse and store DICOM file
def parse_and_store_dicom(file_path: str):
    try:
        print(f"ℹ️ Parsing file: {file_path}")

        # Read metadata using pydicom
        dicom_data = pydicom.dcmread(file_path)

        # Patient Name (handle empty cases)
        patient_name = dicom_data.get("PatientName", "Unknown")
        if isinstance(patient_name, pydicom.valuerep.PersonName):
            patient_name = f"{patient_name.family_name}, {patient_name.given_name}"
        else:
            patient_name = str(patient_name) if patient_name else "Unknown"

        # Study Date
        study_date = dicom_data.get("StudyDate", "")
        if study_date:
            study_date = datetime.strptime(study_date, "%Y%m%d").strftime("%d-%b-%Y")
        else:
            study_date = "Unknown"

        # Modality
        modality = dicom_data.get("Modality", "Unknown")

        # ✅ Save metadata to DB
        db = SessionLocal()
        dicom_entry = DicomFile(
            filename=os.path.basename(file_path),
            patient_name=str(patient_name),
            study_date=str(study_date),
            modality=str(modality),
            file_path=file_path,
        )
        db.add(dicom_entry)
        db.commit()
        db.close()

        print(f"✅ Metadata saved for file: {file_path}")
        print(f"➡️ Patient Name: {patient_name}")
        print(f"➡️ Study Date: {study_date}")
        print(f"➡️ Modality: {modality}")

    except Exception as e:
        print(f"❌ Error: {e}")
        raise HTTPException(status_code=400, detail=str(e))

# ✅ Endpoint 1: Upload and parse DICOM file
@app.post("/upload/")
async def upload_dicom(file: UploadFile = File(...)):
    try:
        # ✅ Debug file information
        print(f"➡️ Received file: {file.filename}")

        # Ensure the filename is safe
        if not file.filename.lower().endswith(".dcm"):
            raise HTTPException(status_code=400, detail="Invalid file format. Only DICOM files are allowed")

        file_path = os.path.join(UPLOAD_DIR, file.filename)
        print(f"File path: {file_path}")

        # ✅ Save file to storage
        file_content = await file.read()
        with open(file_path, "wb") as f:
            f.write(file_content)

        print(f"✅ File saved at: {file_path}")

        # ✅ Validate the file
        if not is_valid_dicom(file_path):
            os.remove(file_path)  # Delete the invalid file
            raise HTTPException(status_code=400, detail="Invalid DICOM file")

        # ✅ Parse and store
        parse_and_store_dicom(file_path)

        return JSONResponse(
            status_code=200,
            content={
                "filename": file.filename,
                "message": "File uploaded and metadata stored successfully"
            }
        )

    except Exception as e:
        print(f"❌ Upload Error: {e}")
        raise HTTPException(status_code=400, detail=str(e))

# ✅ Endpoint 2: Get metadata by filename
@app.get("/metadata/{filename}")
def get_metadata(filename: str):
    print(f"➡️ Fetching metadata for: {filename}")

    db = SessionLocal()
    file_data = db.query(DicomFile).filter(DicomFile.filename == filename).first()
    db.close()

    if not file_data:
        raise HTTPException(status_code=404, detail="File not found")

    print(f"✅ Metadata found for: {filename}")
    return {
        "filename": file_data.filename,
        "patient_name": file_data.patient_name,
        "study_date": file_data.study_date,
        "modality": file_data.modality,
        "file_path": file_data.file_path,
    }

# ✅ Endpoint 3: List all uploaded DICOM files
@app.get("/files/")
def list_files():
    print("➡️ Listing all uploaded files...")

    db = SessionLocal()
    files = db.query(DicomFile).all()
    db.close()

    if not files:
        raise HTTPException(status_code=404, detail="No files found")

    print(f"✅ Found {len(files)} files.")
    return [
        {
            "filename": file.filename,
            "patient_name": file.patient_name,
            "study_date": file.study_date,
            "modality": file.modality,
            "file_path": file.file_path,
        }
        for file in files
    ]

# ✅ Test direct parsing (for debugging)
if __name__ == "__main__":
    import uvicorn
    test_file_path = os.path.join(UPLOAD_DIR, "test.dcm")
    print(f"➡️ Testing file: {test_file_path}")

    if os.path.exists(test_file_path):
        parse_and_store_dicom(test_file_path)
    else:
        print(f"❌ Test file not found at: {test_file_path}")

    uvicorn.run(app, host="127.0.0.1", port=8000)



    3rd


    from fastapi import FastAPI, UploadFile, File, HTTPException
from fastapi.responses import JSONResponse
import os
import pydicom
from sqlalchemy import create_engine, Column, Integer, String, text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime

# ✅ Database Configuration
DATABASE_URL = "postgresql://dicomuser:123@localhost:5432/dicomdb"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# ✅ Extended DICOM Model
class DicomFile(Base):
    __tablename__ = 'dicom_files'

    id = Column(Integer, primary_key=True, index=True)
    filename = Column(String, unique=True, index=True)
    patient_id = Column(String)
    patient_name = Column(String)
    patient_birth_date = Column(String)
    patient_sex = Column(String)
    patient_age = Column(String)
    patient_weight = Column(String)
    patient_address = Column(String)
    study_date = Column(String)
    study_time = Column(String)
    study_id = Column(String)
    study_modality = Column(String)
    study_description = Column(String)
    series_date = Column(String)
    series_time = Column(String)
    series_description = Column(String)
    file_path = Column(String)

# ✅ Create tables
Base.metadata.create_all(bind=engine)

# ✅ FastAPI App
app = FastAPI()

# ✅ Create Upload Directory
UPLOAD_DIR = os.path.join(os.path.dirname(__file__), "uploads")
os.makedirs(UPLOAD_DIR, exist_ok=True)

# ✅ Function to validate DICOM file
def is_valid_dicom(file_path: str) -> bool:
    try:
        pydicom.dcmread(file_path)
        return True
    except Exception as e:
        print(f"❌ Invalid DICOM file: {e}")
        return False

# ✅ Function to parse and store DICOM file
def parse_and_store_dicom(file_path: str):
    try:
        dicom_data = pydicom.dcmread(file_path)

        # Extracting metadata
        patient_id = getattr(dicom_data, "PatientID", "Unknown")
        
        patient_name = getattr(dicom_data, "PatientName", "Unknown")
        if hasattr(patient_name, 'family_name') and hasattr(patient_name, 'given_name'):
            patient_name = f"{patient_name.family_name}, {patient_name.given_name}"
        else:
            patient_name = str(patient_name)

        patient_birth_date = getattr(dicom_data, "PatientBirthDate", "")
        if patient_birth_date:
            patient_birth_date = datetime.strptime(str(patient_birth_date), "%Y%m%d").strftime("%d-%b-%Y")

        patient_sex = getattr(dicom_data, "PatientSex", "Unknown")
        patient_address = getattr(dicom_data, "PatientAddress", "Unknown")
        patient_weight = str(getattr(dicom_data, "PatientWeight", "Unknown"))
        patient_age = str(getattr(dicom_data, "PatientAge", "Unknown"))

        study_date = getattr(dicom_data, "StudyDate", "")
        if study_date:
            study_date = datetime.strptime(str(study_date), "%Y%m%d").strftime("%d-%b-%Y")

        study_time = getattr(dicom_data, "StudyTime", "Unknown")
        study_id = getattr(dicom_data, "StudyID", "Unknown")
        
        # ✅ Fix: Access Modality tag correctly
        study_modality = getattr(dicom_data, "Modality", "Unknown")
        if study_modality == "Unknown":
            if (0x0008, 0x0060) in dicom_data:
                study_modality = dicom_data[0x0008, 0x0060].value

        study_description = getattr(dicom_data, "StudyDescription", "Unknown")

        series_date = getattr(dicom_data, "SeriesDate", "")
        if series_date:
            series_date = datetime.strptime(str(series_date), "%Y%m%d").strftime("%d-%b-%Y")

        series_time = getattr(dicom_data, "SeriesTime", "Unknown")
        series_description = getattr(dicom_data, "SeriesDescription", "Unknown")

        # ✅ Save metadata to DB
        db = SessionLocal()
        dicom_entry = DicomFile(
            filename=os.path.basename(file_path),
            patient_id=patient_id,
            patient_name=patient_name,
            patient_birth_date=patient_birth_date,
            patient_sex=patient_sex,
            patient_age=patient_age,
            patient_weight=patient_weight,
            patient_address=patient_address,
            study_date=study_date,
            study_time=study_time,
            study_id=study_id,
            study_modality=study_modality,
            study_description=study_description,
            series_date=series_date,
            series_time=series_time,
            series_description=series_description,
            file_path=file_path,
        )
        db.add(dicom_entry)
        db.commit()
        db.close()

    except Exception as e:
        print(f"❌ Error: {e}")
        raise HTTPException(status_code=400, detail=str(e))

# ✅ Function to reset ID sequence
def reset_id_sequence():
    db = SessionLocal()
    try:
        # Delete all records
        db.query(DicomFile).delete()
        db.commit()
        
        # Reset the ID sequence to 1
        db.execute(text("ALTER SEQUENCE dicom_files_id_seq RESTART WITH 1"))
        db.commit()
        print("✅ ID sequence reset to 1")
    except Exception as e:
        db.rollback()
        print(f"❌ Error resetting ID sequence: {e}")
    finally:
        db.close()

# ✅ Endpoint 1: Upload and parse DICOM file
@app.post("/upload/")
async def upload_dicom(file: UploadFile = File(...)):
    if not file.filename.lower().endswith(".dcm"):
        raise HTTPException(status_code=400, detail="Invalid file format. Only DICOM files are allowed")

    file_path = os.path.join(UPLOAD_DIR, file.filename)

    file_content = await file.read()
    with open(file_path, "wb") as f:
        f.write(file_content)

    if not is_valid_dicom(file_path):
        os.remove(file_path)
        raise HTTPException(status_code=400, detail="Invalid DICOM file")

    parse_and_store_dicom(file_path)

    return JSONResponse(
        status_code=200,
        content={"filename": file.filename, "message": "File uploaded and metadata stored successfully"}
    )

# ✅ Endpoint 2: Get metadata by filename
@app.get("/metadata/{filename}")
def get_metadata(filename: str):
    db = SessionLocal()
    file_data = db.query(DicomFile).filter(DicomFile.filename == filename).first()
    db.close()

    if not file_data:
        raise HTTPException(status_code=404, detail="File not found")

    return {
        "filename": file_data.filename,
        "patient_id": file_data.patient_id,
        "patient_name": file_data.patient_name,
        "study_date": file_data.study_date,
        "modality": file_data.study_modality,
    }

# ✅ Endpoint 3: List all uploaded DICOM files
@app.get("/files/")
def list_files():
    db = SessionLocal()
    files = db.query(DicomFile).all()
    db.close()

    return [
        {
            "filename": file.filename,
            "patient_name": file.patient_name,
            "study_date": file.study_date,
            "modality": file.study_modality,
            "series_description": file.series_description,
        }
        for file in files
    ]

# ✅ Endpoint 4: Delete all records and reset ID sequence
@app.delete("/delete-all/")
def delete_all_records():
    reset_id_sequence()
    return {"message": "All records deleted and ID sequence reset to 1"}

# ✅ Start FastAPI app
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8000)



    4th

    from fastapi import FastAPI, UploadFile, File, HTTPException
from fastapi.responses import JSONResponse
import os
import pydicom
from sqlalchemy import create_engine, Column, Integer, String, text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime
import requests
from urllib.parse import urlparse

# ✅ Database Configuration
DATABASE_URL = "postgresql://dicomuser:123@localhost:5432/dicomdb"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# ✅ Extended DICOM Model
class DicomFile(Base):
    __tablename__ = 'dicom_files'

    id = Column(Integer, primary_key=True, index=True)
    filename = Column(String, unique=True, index=True)
    patient_id = Column(String)
    patient_name = Column(String)
    patient_birth_date = Column(String)
    patient_sex = Column(String)
    patient_age = Column(String)
    patient_weight = Column(String)
    patient_address = Column(String)
    study_date = Column(String)
    study_time = Column(String)
    study_id = Column(String)
    study_modality = Column(String)
    study_description = Column(String)
    series_date = Column(String)
    series_time = Column(String)
    series_description = Column(String)
    file_path = Column(String)

# ✅ Create tables
Base.metadata.create_all(bind=engine)

# ✅ FastAPI App
app = FastAPI()

# ✅ Create Upload Directory
UPLOAD_DIR = os.path.join(os.path.dirname(__file__), "uploads")
os.makedirs(UPLOAD_DIR, exist_ok=True)

# ✅ Function to validate DICOM file
def is_valid_dicom(file_path: str) -> bool:
    try:
        pydicom.dcmread(file_path)
        return True
    except Exception as e:
        print(f"❌ Invalid DICOM file: {e}")
        return False

# ✅ Function to parse and store DICOM file
def parse_and_store_dicom(file_path: str):
    try:
        dicom_data = pydicom.dcmread(file_path)

        # Extracting metadata
        patient_id = getattr(dicom_data, "PatientID", "Unknown")
        
        patient_name = getattr(dicom_data, "PatientName", "Unknown")
        if hasattr(patient_name, 'family_name') and hasattr(patient_name, 'given_name'):
            patient_name = f"{patient_name.family_name}, {patient_name.given_name}"
        else:
            patient_name = str(patient_name)

        patient_birth_date = getattr(dicom_data, "PatientBirthDate", "")
        if patient_birth_date:
            patient_birth_date = datetime.strptime(str(patient_birth_date), "%Y%m%d").strftime("%d-%b-%Y")

        patient_sex = getattr(dicom_data, "PatientSex", "Unknown")
        patient_address = getattr(dicom_data, "PatientAddress", "Unknown")
        patient_weight = str(getattr(dicom_data, "PatientWeight", "Unknown"))
        patient_age = str(getattr(dicom_data, "PatientAge", "Unknown"))

        study_date = getattr(dicom_data, "StudyDate", "")
        if study_date:
            study_date = datetime.strptime(str(study_date), "%Y%m%d").strftime("%d-%b-%Y")

        study_time = getattr(dicom_data, "StudyTime", "Unknown")
        study_id = getattr(dicom_data, "StudyID", "Unknown")
        
        # ✅ Fix: Access Modality tag correctly
        study_modality = getattr(dicom_data, "Modality", "Unknown")
        if study_modality == "Unknown":
            if (0x0008, 0x0060) in dicom_data:
                study_modality = dicom_data[0x0008, 0x0060].value

        study_description = getattr(dicom_data, "StudyDescription", "Unknown")

        series_date = getattr(dicom_data, "SeriesDate", "")
        if series_date:
            series_date = datetime.strptime(str(series_date), "%Y%m%d").strftime("%d-%b-%Y")

        series_time = getattr(dicom_data, "SeriesTime", "Unknown")
        series_description = getattr(dicom_data, "SeriesDescription", "Unknown")

        # ✅ Save metadata to DB
        db = SessionLocal()
        dicom_entry = DicomFile(
            filename=os.path.basename(file_path),
            patient_id=patient_id,
            patient_name=patient_name,
            patient_birth_date=patient_birth_date,
            patient_sex=patient_sex,
            patient_age=patient_age,
            patient_weight=patient_weight,
            patient_address=patient_address,
            study_date=study_date,
            study_time=study_time,
            study_id=study_id,
            study_modality=study_modality,
            study_description=study_description,
            series_date=series_date,
            series_time=series_time,
            series_description=series_description,
            file_path=file_path,
        )
        db.add(dicom_entry)
        db.commit()
        db.close()

    except Exception as e:
        print(f"❌ Error: {e}")
        raise HTTPException(status_code=400, detail=str(e))

# ✅ Function to reset ID sequence
def reset_id_sequence():
    db = SessionLocal()
    try:
        # Delete all records
        db.query(DicomFile).delete()
        db.commit()
        
        # Reset the ID sequence to 1
        db.execute(text("ALTER SEQUENCE dicom_files_id_seq RESTART WITH 1"))
        db.commit()
        print("✅ ID sequence reset to 1")
    except Exception as e:
        db.rollback()
        print(f"❌ Error resetting ID sequence: {e}")
    finally:
        db.close()

# ✅ Endpoint 1: Upload and parse DICOM file (local file upload)
@app.post("/upload/")
async def upload_dicom(file: UploadFile = File(...)):
    if not file.filename.lower().endswith(".dcm"):
        raise HTTPException(status_code=400, detail="Invalid file format. Only DICOM files are allowed")

    file_path = os.path.join(UPLOAD_DIR, file.filename)

    file_content = await file.read()
    with open(file_path, "wb") as f:
        f.write(file_content)

    if not is_valid_dicom(file_path):
        os.remove(file_path)
        raise HTTPException(status_code=400, detail="Invalid DICOM file")

    parse_and_store_dicom(file_path)

    return JSONResponse(
        status_code=200,
        content={"filename": file.filename, "message": "File uploaded and metadata stored successfully"}
    )

# ✅ Endpoint 2: Upload and parse DICOM file (remote URL)
@app.post("/upload-from-url/")
async def upload_dicom_from_url(url: str):
    try:
        # Download the file from the URL
        response = requests.get(url)
        if response.status_code != 200:
            raise HTTPException(status_code=400, detail="Failed to download the file")

        # Extract the filename from the URL
        parsed_url = urlparse(url)
        filename = os.path.basename(parsed_url.path)
        if not filename.lower().endswith(".dcm"):
            raise HTTPException(status_code=400, detail="Invalid file format. Only DICOM files are allowed")

        file_path = os.path.join(UPLOAD_DIR, filename)

        # Save the downloaded file
        with open(file_path, "wb") as f:
            f.write(response.content)

        if not is_valid_dicom(file_path):
            os.remove(file_path)
            raise HTTPException(status_code=400, detail="Invalid DICOM file")

        parse_and_store_dicom(file_path)

        return JSONResponse(
            status_code=200,
            content={"filename": filename, "message": "File uploaded and metadata stored successfully"}
        )
    except Exception as e:
        print(f"❌ Error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# ✅ Endpoint 3: Get metadata by filename
@app.get("/metadata/{filename}")
def get_metadata(filename: str):
    db = SessionLocal()
    file_data = db.query(DicomFile).filter(DicomFile.filename == filename).first()
    db.close()

    if not file_data:
        raise HTTPException(status_code=404, detail="File not found")

    return {
        "filename": file_data.filename,
        "patient_id": file_data.patient_id,
        "patient_name": file_data.patient_name,
        "study_date": file_data.study_date,
        "modality": file_data.study_modality,
    }

# ✅ Endpoint 4: List all uploaded DICOM files
@app.get("/files/")
def list_files():
    db = SessionLocal()
    files = db.query(DicomFile).all()
    db.close()

    return [
        {
            "filename": file.filename,
            "patient_name": file.patient_name,
            "study_date": file.study_date,
            "modality": file.study_modality,
            "series_description": file.series_description,
        }
        for file in files
    ]

# ✅ Endpoint 5: Delete all records and reset ID sequence
@app.delete("/delete-all/")
def delete_all_records():
    reset_id_sequence()
    return {"message": "All records deleted and ID sequence reset to 1"}

# ✅ Start FastAPI app
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8000)


    5 th

    from fastapi import FastAPI, UploadFile, File, HTTPException
from fastapi.responses import JSONResponse
import os
import pydicom
from sqlalchemy import create_engine, Column, Integer, String, text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime
import requests
from urllib.parse import urlparse

# ✅ Database Configuration
# Use the Render PostgreSQL internal URL
DATABASE_URL = os.getenv("DATABASE_URL", "postgresql://database_h9fh_user:uVn8TArSohaWM2EMyqO0uNngONOuaF4n@dpg-cv9jigtumphs73a86lfg-a/database_h9fh")

# Fix the URL for SQLAlchemy (replace 'postgres://' with 'postgresql://')
if DATABASE_URL.startswith("postgres://"):
    DATABASE_URL = DATABASE_URL.replace("postgres://", "postgresql://", 1)

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# ✅ Extended DICOM Model
class DicomFile(Base):
    __tablename__ = 'dicom_files'

    id = Column(Integer, primary_key=True, index=True)
    filename = Column(String, unique=True, index=True)
    patient_id = Column(String)
    patient_name = Column(String)
    patient_birth_date = Column(String)
    patient_sex = Column(String)
    patient_age = Column(String)
    patient_weight = Column(String)
    patient_address = Column(String)
    study_date = Column(String)
    study_time = Column(String)
    study_id = Column(String)
    study_modality = Column(String)
    study_description = Column(String)
    series_date = Column(String)
    series_time = Column(String)
    series_description = Column(String)
    file_path = Column(String)

# ✅ Create tables
Base.metadata.create_all(bind=engine)

# ✅ FastAPI App
app = FastAPI()

# ✅ Create Upload Directory
UPLOAD_DIR = os.path.join(os.path.dirname(__file__), "uploads")
os.makedirs(UPLOAD_DIR, exist_ok=True)

# ✅ Function to validate DICOM file
def is_valid_dicom(file_path: str) -> bool:
    try:
        pydicom.dcmread(file_path)
        return True
    except Exception as e:
        print(f"❌ Invalid DICOM file: {e}")
        return False

# ✅ Function to parse and store DICOM file
def parse_and_store_dicom(file_path: str):
    try:
        dicom_data = pydicom.dcmread(file_path)

        # Extracting metadata
        patient_id = getattr(dicom_data, "PatientID", "Unknown")
        
        patient_name = getattr(dicom_data, "PatientName", "Unknown")
        if hasattr(patient_name, 'family_name') and hasattr(patient_name, 'given_name'):
            patient_name = f"{patient_name.family_name}, {patient_name.given_name}"
        else:
            patient_name = str(patient_name)

        patient_birth_date = getattr(dicom_data, "PatientBirthDate", "")
        if patient_birth_date:
            patient_birth_date = datetime.strptime(str(patient_birth_date), "%Y%m%d").strftime("%d-%b-%Y")

        patient_sex = getattr(dicom_data, "PatientSex", "Unknown")
        patient_address = getattr(dicom_data, "PatientAddress", "Unknown")
        patient_weight = str(getattr(dicom_data, "PatientWeight", "Unknown"))
        patient_age = str(getattr(dicom_data, "PatientAge", "Unknown"))

        study_date = getattr(dicom_data, "StudyDate", "")
        if study_date:
            study_date = datetime.strptime(str(study_date), "%Y%m%d").strftime("%d-%b-%Y")

        study_time = getattr(dicom_data, "StudyTime", "Unknown")
        study_id = getattr(dicom_data, "StudyID", "Unknown")
        
        # ✅ Fix: Access Modality tag correctly
        study_modality = getattr(dicom_data, "Modality", "Unknown")
        if study_modality == "Unknown":
            if (0x0008, 0x0060) in dicom_data:
                study_modality = dicom_data[0x0008, 0x0060].value

        study_description = getattr(dicom_data, "StudyDescription", "Unknown")

        series_date = getattr(dicom_data, "SeriesDate", "")
        if series_date:
            series_date = datetime.strptime(str(series_date), "%Y%m%d").strftime("%d-%b-%Y")

        series_time = getattr(dicom_data, "SeriesTime", "Unknown")
        series_description = getattr(dicom_data, "SeriesDescription", "Unknown")

        # ✅ Save metadata to DB
        db = SessionLocal()
        dicom_entry = DicomFile(
            filename=os.path.basename(file_path),
            patient_id=patient_id,
            patient_name=patient_name,
            patient_birth_date=patient_birth_date,
            patient_sex=patient_sex,
            patient_age=patient_age,
            patient_weight=patient_weight,
            patient_address=patient_address,
            study_date=study_date,
            study_time=study_time,
            study_id=study_id,
            study_modality=study_modality,
            study_description=study_description,
            series_date=series_date,
            series_time=series_time,
            series_description=series_description,
            file_path=file_path,
        )
        db.add(dicom_entry)
        db.commit()
        db.close()

    except Exception as e:
        print(f"❌ Error: {e}")
        raise HTTPException(status_code=400, detail=str(e))

# ✅ Function to reset ID sequence
def reset_id_sequence():
    db = SessionLocal()
    try:
        # Delete all records
        db.query(DicomFile).delete()
        db.commit()
        
        # Reset the ID sequence to 1
        db.execute(text("ALTER SEQUENCE dicom_files_id_seq RESTART WITH 1"))
        db.commit()
        print("✅ ID sequence reset to 1")
    except Exception as e:
        db.rollback()
        print(f"❌ Error resetting ID sequence: {e}")
    finally:
        db.close()

# ✅ Endpoint 1: Upload and parse DICOM file (local file upload)
@app.post("/upload/")
async def upload_dicom(file: UploadFile = File(...)):
    if not file.filename.lower().endswith(".dcm"):
        raise HTTPException(status_code=400, detail="Invalid file format. Only DICOM files are allowed")

    file_path = os.path.join(UPLOAD_DIR, file.filename)

    file_content = await file.read()
    with open(file_path, "wb") as f:
        f.write(file_content)

    if not is_valid_dicom(file_path):
        os.remove(file_path)
        raise HTTPException(status_code=400, detail="Invalid DICOM file")

    parse_and_store_dicom(file_path)

    return JSONResponse(
        status_code=200,
        content={"filename": file.filename, "message": "File uploaded and metadata stored successfully"}
    )

# ✅ Endpoint 2: Upload and parse DICOM file (remote URL)
@app.post("/upload-from-url/")
async def upload_dicom_from_url(url: str):
    try:
        # Download the file from the URL
        response = requests.get(url)
        if response.status_code != 200:
            raise HTTPException(status_code=400, detail="Failed to download the file")

        # Extract the filename from the URL
        parsed_url = urlparse(url)
        filename = os.path.basename(parsed_url.path)
        if not filename.lower().endswith(".dcm"):
            raise HTTPException(status_code=400, detail="Invalid file format. Only DICOM files are allowed")

        file_path = os.path.join(UPLOAD_DIR, filename)

        # Save the downloaded file
        with open(file_path, "wb") as f:
            f.write(response.content)

        if not is_valid_dicom(file_path):
            os.remove(file_path)
            raise HTTPException(status_code=400, detail="Invalid DICOM file")

        parse_and_store_dicom(file_path)

        return JSONResponse(
            status_code=200,
            content={"filename": filename, "message": "File uploaded and metadata stored successfully"}
        )
    except Exception as e:
        print(f"❌ Error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# ✅ Endpoint 3: Get metadata by filename
@app.get("/metadata/{filename}")
def get_metadata(filename: str):
    db = SessionLocal()
    file_data = db.query(DicomFile).filter(DicomFile.filename == filename).first()
    db.close()

    if not file_data:
        raise HTTPException(status_code=404, detail="File not found")

    return {
        "filename": file_data.filename,
        "patient_id": file_data.patient_id,
        "patient_name": file_data.patient_name,
        "study_date": file_data.study_date,
        "modality": file_data.study_modality,
    }

# ✅ Endpoint 4: List all uploaded DICOM files
@app.get("/files/")
def list_files():
    db = SessionLocal()
    files = db.query(DicomFile).all()
    db.close()

    return [
        {
            "filename": file.filename,
            "patient_name": file.patient_name,
            "study_date": file.study_date,
            "modality": file.study_modality,
            "series_description": file.series_description,
        }
        for file in files
    ]

# ✅ Endpoint 5: Delete all records and reset ID sequence
@app.delete("/delete-all/")
def delete_all_records():
    reset_id_sequence()
    return {"message": "All records deleted and ID sequence reset to 1"}

# ✅ Start FastAPI app
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8000)


    6th

    from fastapi import FastAPI, UploadFile, File, HTTPException
from fastapi.responses import JSONResponse
import os
import pydicom
from sqlalchemy import create_engine, Column, Integer, String, text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime
import requests
from urllib.parse import urlparse
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ✅ Database Configuration
# Use the Render PostgreSQL external URL
DATABASE_URL = "postgresql://database_h9fh_user:uVn8TArSohaWM2EMyqO0uNngONOuaF4n@dpg-cv9jigtumphs73a86lfg-a.oregon-postgres.render.com/database_h9fh"

# Fix the URL for SQLAlchemy (replace 'postgres://' with 'postgresql://')
if DATABASE_URL.startswith("postgres://"):
    DATABASE_URL = DATABASE_URL.replace("postgres://", "postgresql://", 1)

logger.info(f"Database URL: {DATABASE_URL}")

# Create the SQLAlchemy engine
try:
    engine = create_engine(DATABASE_URL)
    logger.info("✅ Engine created successfully!")
except Exception as e:
    logger.error(f"❌ Failed to create engine: {e}")
    raise

# Test the database connection
try:
    with engine.connect() as connection:
        logger.info("✅ Successfully connected to the database!")
except Exception as e:
    logger.error(f"❌ Failed to connect to the database: {e}")
    raise

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# ✅ Extended DICOM Model
class DicomFile(Base):
    __tablename__ = 'dicom_files'

    id = Column(Integer, primary_key=True, index=True)
    filename = Column(String, unique=True, index=True)
    patient_id = Column(String)
    patient_name = Column(String)
    patient_birth_date = Column(String)
    patient_sex = Column(String)
    patient_age = Column(String)
    patient_weight = Column(String)
    patient_address = Column(String)
    study_date = Column(String)
    study_time = Column(String)
    study_id = Column(String)
    study_modality = Column(String)
    study_description = Column(String)
    series_date = Column(String)
    series_time = Column(String)
    series_description = Column(String)
    file_path = Column(String)

# ✅ Create tables
try:
    Base.metadata.create_all(bind=engine)
    logger.info("✅ Tables created successfully!")
except Exception as e:
    logger.error(f"❌ Error creating tables: {e}")
    raise

# ✅ FastAPI App
app = FastAPI()

# ✅ Create Upload Directory
UPLOAD_DIR = os.path.join(os.path.dirname(__file__), "uploads")
os.makedirs(UPLOAD_DIR, exist_ok=True)
logger.info(f"Upload directory: {UPLOAD_DIR}")

# ✅ Function to validate DICOM file
def is_valid_dicom(file_path: str) -> bool:
    try:
        pydicom.dcmread(file_path)
        return True
    except Exception as e:
        logger.error(f"❌ Invalid DICOM file: {e}")
        return False

# ✅ Function to parse and store DICOM file
def parse_and_store_dicom(file_path: str):
    try:
        dicom_data = pydicom.dcmread(file_path)

        # Extracting metadata
        patient_id = getattr(dicom_data, "PatientID", "Unknown")
        
        patient_name = getattr(dicom_data, "PatientName", "Unknown")
        if hasattr(patient_name, 'family_name') and hasattr(patient_name, 'given_name'):
            patient_name = f"{patient_name.family_name}, {patient_name.given_name}"
        else:
            patient_name = str(patient_name)

        patient_birth_date = getattr(dicom_data, "PatientBirthDate", "")
        if patient_birth_date:
            patient_birth_date = datetime.strptime(str(patient_birth_date), "%Y%m%d").strftime("%d-%b-%Y")

        patient_sex = getattr(dicom_data, "PatientSex", "Unknown")
        patient_address = getattr(dicom_data, "PatientAddress", "Unknown")
        patient_weight = str(getattr(dicom_data, "PatientWeight", "Unknown"))
        patient_age = str(getattr(dicom_data, "PatientAge", "Unknown"))

        study_date = getattr(dicom_data, "StudyDate", "")
        if study_date:
            study_date = datetime.strptime(str(study_date), "%Y%m%d").strftime("%d-%b-%Y")

        study_time = getattr(dicom_data, "StudyTime", "Unknown")
        study_id = getattr(dicom_data, "StudyID", "Unknown")
        
        # ✅ Fix: Access Modality tag correctly
        study_modality = getattr(dicom_data, "Modality", "Unknown")
        if study_modality == "Unknown":
            if (0x0008, 0x0060) in dicom_data:
                study_modality = dicom_data[0x0008, 0x0060].value

        study_description = getattr(dicom_data, "StudyDescription", "Unknown")

        series_date = getattr(dicom_data, "SeriesDate", "")
        if series_date:
            series_date = datetime.strptime(str(series_date), "%Y%m%d").strftime("%d-%b-%Y")

        series_time = getattr(dicom_data, "SeriesTime", "Unknown")
        series_description = getattr(dicom_data, "SeriesDescription", "Unknown")

        # ✅ Save metadata to DB
        db = SessionLocal()
        dicom_entry = DicomFile(
            filename=os.path.basename(file_path),
            patient_id=patient_id,
            patient_name=patient_name,
            patient_birth_date=patient_birth_date,
            patient_sex=patient_sex,
            patient_age=patient_age,
            patient_weight=patient_weight,
            patient_address=patient_address,
            study_date=study_date,
            study_time=study_time,
            study_id=study_id,
            study_modality=study_modality,
            study_description=study_description,
            series_date=series_date,
            series_time=series_time,
            series_description=series_description,
            file_path=file_path,
        )
        db.add(dicom_entry)
        db.commit()
        db.close()
        logger.info(f"✅ Metadata stored for file: {os.path.basename(file_path)}")

    except Exception as e:
        logger.error(f"❌ Error parsing and storing DICOM file: {e}")
        raise HTTPException(status_code=400, detail=str(e))

# ✅ Function to reset ID sequence
def reset_id_sequence():
    db = SessionLocal()
    try:
        # Delete all records
        db.query(DicomFile).delete()
        db.commit()
        
        # Reset the ID sequence to 1
        db.execute(text("ALTER SEQUENCE dicom_files_id_seq RESTART WITH 1"))
        db.commit()
        logger.info("✅ ID sequence reset to 1")
    except Exception as e:
        db.rollback()
        logger.error(f"❌ Error resetting ID sequence: {e}")
    finally:
        db.close()

# ✅ Endpoint 1: Upload and parse DICOM file (local file upload)
@app.post("/upload/")
async def upload_dicom(file: UploadFile = File(...)):
    if not file.filename.lower().endswith(".dcm"):
        raise HTTPException(status_code=400, detail="Invalid file format. Only DICOM files are allowed")

    file_path = os.path.join(UPLOAD_DIR, file.filename)

    file_content = await file.read()
    with open(file_path, "wb") as f:
        f.write(file_content)

    if not is_valid_dicom(file_path):
        os.remove(file_path)
        raise HTTPException(status_code=400, detail="Invalid DICOM file")

    parse_and_store_dicom(file_path)

    return JSONResponse(
        status_code=200,
        content={"filename": file.filename, "message": "File uploaded and metadata stored successfully"}
    )

# ✅ Endpoint 2: Upload and parse DICOM file (remote URL)
@app.post("/upload-from-url/")
async def upload_dicom_from_url(url: str):
    try:
        # Download the file from the URL
        response = requests.get(url)
        if response.status_code != 200:
            raise HTTPException(status_code=400, detail="Failed to download the file")

        # Extract the filename from the URL
        parsed_url = urlparse(url)
        filename = os.path.basename(parsed_url.path)
        if not filename.lower().endswith(".dcm"):
            raise HTTPException(status_code=400, detail="Invalid file format. Only DICOM files are allowed")

        file_path = os.path.join(UPLOAD_DIR, filename)

        # Save the downloaded file
        with open(file_path, "wb") as f:
            f.write(response.content)

        if not is_valid_dicom(file_path):
            os.remove(file_path)
            raise HTTPException(status_code=400, detail="Invalid DICOM file")

        parse_and_store_dicom(file_path)

        return JSONResponse(
            status_code=200,
            content={"filename": filename, "message": "File uploaded and metadata stored successfully"}
        )
    except Exception as e:
        logger.error(f"❌ Error uploading DICOM file from URL: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# ✅ Endpoint 3: Get metadata by filename
@app.get("/metadata/{filename}")
def get_metadata(filename: str):
    db = SessionLocal()
    file_data = db.query(DicomFile).filter(DicomFile.filename == filename).first()
    db.close()

    if not file_data:
        raise HTTPException(status_code=404, detail="File not found")

    return {
        "filename": file_data.filename,
        "patient_id": file_data.patient_id,
        "patient_name": file_data.patient_name,
        "study_date": file_data.study_date,
        "modality": file_data.study_modality,
    }

# ✅ Endpoint 4: List all uploaded DICOM files
@app.get("/files/")
def list_files():
    db = SessionLocal()
    files = db.query(DicomFile).all()
    db.close()

    return [
        {
            "filename": file.filename,
            "patient_name": file.patient_name,
            "study_date": file.study_date,
            "modality": file.study_modality,
            "series_description": file.series_description,
        }
        for file in files
    ]

# ✅ Endpoint 5: Delete all records and reset ID sequence
@app.delete("/delete-all/")
def delete_all_records():
    reset_id_sequence()
    return {"message": "All records deleted and ID sequence reset to 1"}

# ✅ Start FastAPI app
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8000)


    7th

    from fastapi import FastAPI, UploadFile, File, HTTPException
from fastapi.responses import JSONResponse
import os
import pydicom
from sqlalchemy import create_engine, Column, Integer, String, text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime
import requests
from urllib.parse import urlparse
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ✅ Database Configuration
# Use the Render PostgreSQL external URL
DATABASE_URL = "postgresql://database_h9fh_user:uVn8TArSohaWM2EMyqO0uNngONOuaF4n@dpg-cv9jigtumphs73a86lfg-a.oregon-postgres.render.com/database_h9fh"

# Fix the URL for SQLAlchemy (replace 'postgres://' with 'postgresql://')
if DATABASE_URL.startswith("postgres://"):
    DATABASE_URL = DATABASE_URL.replace("postgres://", "postgresql://", 1)

logger.info(f"Database URL: {DATABASE_URL}")

# Create the SQLAlchemy engine
try:
    engine = create_engine(DATABASE_URL)
    logger.info("✅ Engine created successfully!")
except Exception as e:
    logger.error(f"❌ Failed to create engine: {e}")
    raise

# Test the database connection
try:
    with engine.connect() as connection:
        logger.info("✅ Successfully connected to the database!")
except Exception as e:
    logger.error(f"❌ Failed to connect to the database: {e}")
    raise

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# ✅ Extended DICOM Model
class DicomFile(Base):
    __tablename__ = 'dicom_files'

    id = Column(Integer, primary_key=True, index=True)
    filename = Column(String, unique=True, index=True)
    patient_id = Column(String)
    patient_name = Column(String)
    patient_birth_date = Column(String)
    patient_sex = Column(String)
    patient_age = Column(String)
    patient_weight = Column(String)
    patient_address = Column(String)
    study_date = Column(String)
    study_time = Column(String)
    study_id = Column(String)
    study_modality = Column(String)
    study_description = Column(String)
    series_date = Column(String)
    series_time = Column(String)
    series_description = Column(String)
    file_path = Column(String)

# ✅ Create tables
try:
    Base.metadata.create_all(bind=engine)
    logger.info("✅ Tables created successfully!")
except Exception as e:
    logger.error(f"❌ Error creating tables: {e}")
    raise

# ✅ FastAPI App
app = FastAPI()

# ✅ Create Upload Directory
UPLOAD_DIR = os.path.join(os.path.dirname(__file__), "uploads")
os.makedirs(UPLOAD_DIR, exist_ok=True)
logger.info(f"Upload directory: {UPLOAD_DIR}")

# ✅ Function to validate DICOM file
def is_valid_dicom(file_path: str) -> bool:
    try:
        pydicom.dcmread(file_path)
        return True
    except Exception as e:
        logger.error(f"❌ Invalid DICOM file: {e}")
        return False

# ✅ Function to parse and store DICOM file
def parse_and_store_dicom(file_path: str):
    try:
        dicom_data = pydicom.dcmread(file_path)

        # Extracting metadata
        patient_id = getattr(dicom_data, "PatientID", "Unknown")
        
        patient_name = getattr(dicom_data, "PatientName", "Unknown")
        if hasattr(patient_name, 'family_name') and hasattr(patient_name, 'given_name'):
            patient_name = f"{patient_name.family_name}, {patient_name.given_name}"
        else:
            patient_name = str(patient_name)

        patient_birth_date = getattr(dicom_data, "PatientBirthDate", "")
        if patient_birth_date:
            patient_birth_date = datetime.strptime(str(patient_birth_date), "%Y%m%d").strftime("%d-%b-%Y")

        patient_sex = getattr(dicom_data, "PatientSex", "Unknown")
        patient_address = getattr(dicom_data, "PatientAddress", "Unknown")
        patient_weight = str(getattr(dicom_data, "PatientWeight", "Unknown"))
        patient_age = str(getattr(dicom_data, "PatientAge", "Unknown"))

        study_date = getattr(dicom_data, "StudyDate", "")
        if study_date:
            study_date = datetime.strptime(str(study_date), "%Y%m%d").strftime("%d-%b-%Y")

        study_time = getattr(dicom_data, "StudyTime", "Unknown")
        study_id = getattr(dicom_data, "StudyID", "Unknown")
        
        # ✅ Fix: Access Modality tag correctly
        study_modality = getattr(dicom_data, "Modality", "Unknown")
        if study_modality == "Unknown":
            if (0x0008, 0x0060) in dicom_data:
                study_modality = dicom_data[0x0008, 0x0060].value

        study_description = getattr(dicom_data, "StudyDescription", "Unknown")

        series_date = getattr(dicom_data, "SeriesDate", "")
        if series_date:
            series_date = datetime.strptime(str(series_date), "%Y%m%d").strftime("%d-%b-%Y")

        series_time = getattr(dicom_data, "SeriesTime", "Unknown")
        series_description = getattr(dicom_data, "SeriesDescription", "Unknown")

        # ✅ Save metadata to DB
        db = SessionLocal()
        dicom_entry = DicomFile(
            filename=os.path.basename(file_path),
            patient_id=patient_id,
            patient_name=patient_name,
            patient_birth_date=patient_birth_date,
            patient_sex=patient_sex,
            patient_age=patient_age,
            patient_weight=patient_weight,
            patient_address=patient_address,
            study_date=study_date,
            study_time=study_time,
            study_id=study_id,
            study_modality=study_modality,
            study_description=study_description,
            series_date=series_date,
            series_time=series_time,
            series_description=series_description,
            file_path=file_path,
        )
        db.add(dicom_entry)
        db.commit()
        db.close()
        logger.info(f"✅ Metadata stored for file: {os.path.basename(file_path)}")

    except Exception as e:
        logger.error(f"❌ Error parsing and storing DICOM file: {e}")
        raise HTTPException(status_code=400, detail=str(e))

# ✅ Function to reset ID sequence
def reset_id_sequence():
    db = SessionLocal()
    try:
        # Delete all records
        db.query(DicomFile).delete()
        db.commit()
        
        # Reset the ID sequence to 1
        db.execute(text("ALTER SEQUENCE dicom_files_id_seq RESTART WITH 1"))
        db.commit()
        logger.info("✅ ID sequence reset to 1")
    except Exception as e:
        db.rollback()
        logger.error(f"❌ Error resetting ID sequence: {e}")
    finally:
        db.close()

# ✅ Endpoint 1: Upload and parse DICOM file (local file upload)
@app.post("/upload/")
async def upload_dicom(file: UploadFile = File(...)):
    if not file.filename.lower().endswith(".dcm"):
        raise HTTPException(status_code=400, detail="Invalid file format. Only DICOM files are allowed")

    file_path = os.path.join(UPLOAD_DIR, file.filename)

    file_content = await file.read()
    with open(file_path, "wb") as f:
        f.write(file_content)

    if not is_valid_dicom(file_path):
        os.remove(file_path)
        raise HTTPException(status_code=400, detail="Invalid DICOM file")

    parse_and_store_dicom(file_path)

    return JSONResponse(
        status_code=200,
        content={"filename": file.filename, "message": "File uploaded and metadata stored successfully"}
    )

# ✅ Endpoint 2: Upload and parse DICOM file (remote URL)
@app.post("/upload-from-url/")
async def upload_dicom_from_url(url: str):
    try:
        # Download the file from the URL
        response = requests.get(url)
        if response.status_code != 200:
            raise HTTPException(status_code=400, detail="Failed to download the file")

        # Extract the filename from the URL
        parsed_url = urlparse(url)
        filename = os.path.basename(parsed_url.path)
        if not filename.lower().endswith(".dcm"):
            raise HTTPException(status_code=400, detail="Invalid file format. Only DICOM files are allowed")

        file_path = os.path.join(UPLOAD_DIR, filename)

        # Save the downloaded file
        with open(file_path, "wb") as f:
            f.write(response.content)

        if not is_valid_dicom(file_path):
            os.remove(file_path)
            raise HTTPException(status_code=400, detail="Invalid DICOM file")

        parse_and_store_dicom(file_path)

        return JSONResponse(
            status_code=200,
            content={"filename": filename, "message": "File uploaded and metadata stored successfully"}
        )
    except Exception as e:
        logger.error(f"❌ Error uploading DICOM file from URL: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# ✅ Endpoint 3: Get metadata by filename
# ✅ Endpoint 3: Get metadata by filename
@app.get("/metadata/{filename}")
def get_metadata(filename: str):
    db = SessionLocal()
    file_data = db.query(DicomFile).filter(DicomFile.filename == filename).first()
    db.close()

    if not file_data:
        raise HTTPException(status_code=404, detail="File not found")

    # Return all metadata fields
    return {
        "filename": file_data.filename,
        "patient_id": file_data.patient_id,
        "patient_name": file_data.patient_name,
        "patient_birth_date": file_data.patient_birth_date,
        "patient_sex": file_data.patient_sex,
        "patient_age": file_data.patient_age,
        "patient_weight": file_data.patient_weight,
        "patient_address": file_data.patient_address,
        "study_date": file_data.study_date,
        "study_time": file_data.study_time,
        "study_id": file_data.study_id,
        "study_modality": file_data.study_modality,
        "study_description": file_data.study_description,
        "series_date": file_data.series_date,
        "series_time": file_data.series_time,
        "series_description": file_data.series_description,
        "file_path": file_data.file_path
    }
@app.get("/files/")
def list_files():
    db = SessionLocal()
    files = db.query(DicomFile).all()
    db.close()

    return [
        {
            "filename": file.filename,
            "patient_name": file.patient_name,
            "study_date": file.study_date,
            "modality": file.study_modality,
            "series_description": file.series_description,
        }
        for file in files
    ]

# ✅ Endpoint 5: Delete all records and reset ID sequence
@app.delete("/delete-all/")
def delete_all_records():
    reset_id_sequence()
    return {"message": "All records deleted and ID sequence reset to 1"}

# ✅ Start FastAPI app
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8000)